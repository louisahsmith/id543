[
  {
    "objectID": "cheat_sheet/cheat_sheet.html",
    "href": "cheat_sheet/cheat_sheet.html",
    "title": "Basic R coding overview",
    "section": "",
    "text": "This document aligns with the Stata cheat sheet."
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#create-and-execute-an-r-script",
    "href": "cheat_sheet/cheat_sheet.html#create-and-execute-an-r-script",
    "title": "Basic R coding overview",
    "section": "2.1 Create and execute an R script",
    "text": "2.1 Create and execute an R script\nIn RStudio, you can run R code directly in the console. This is helpful for running quick one-off code. To save your code, write it as an .R script, which allows one to run the same commands in the future to reproduce your work. To open a new .R script, one can:\n\nClick on the “New File” icon in the top left of RStudio, then select “R Script”.\nFile -&gt; New File -&gt; R Script"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#installing-packages",
    "href": "cheat_sheet/cheat_sheet.html#installing-packages",
    "title": "Basic R coding overview",
    "section": "Installing packages",
    "text": "Installing packages\nTo utilize certain functions in R, additional packages often need to be downloaded into R. To install a package, run:\n\ninstall.packages(\"package_name\")\n\nYou can also click on the “Packages” tab in the bottom right window in RStudio. Next click “install” and a small window will pop up, enter the package’s name and hit “install”.\nWhen a function belongs to a package, you can use that function by running package_name::function_name() or by running library(package_name) at some point before function_name()."
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#read-in-a-dataset-.rds-.dta-.xlsx-.csv-.sas7bdat",
    "href": "cheat_sheet/cheat_sheet.html#read-in-a-dataset-.rds-.dta-.xlsx-.csv-.sas7bdat",
    "title": "Basic R coding overview",
    "section": "2.2 Read in a Dataset (.rds, .dta, .xlsx, .csv, .sas7bdat)",
    "text": "2.2 Read in a Dataset (.rds, .dta, .xlsx, .csv, .sas7bdat)\nDatasets can be in various formats, such as “.rds” (R), “.dta” (Stata), “.xlsx” (Excel), “.csv” (Comma Separated Value), and “.sas7bdat” (SAS) files. Some of these datasets require additional packages to download into R.\nYou will need to include the path to the dataset file in your code. To determine the location of a dataset stored on a Windows computer, you can right-click and click on ‘Properties’ and copy and paste the location path. On a Mac, right-click the file, then press Option so that “Copy filename as Pathname” appears in the menu.\nUnlike Stata, you can have multiple datasets open in the same R session. When reading in a dataset, you must store it as an object so that you can refer to it later. This is done in R using the “assignment arrow” &lt;-.\nReading in datasets can also be done from “File” -&gt; “Import Dataset”. This will bring up a window with options that will help you write the code that can be saved in an R script to use again. The “files” tab in the bottom right window of RStudio may also be helpful to import datasets. It operates similarly to Windows Explorer or the Finder on a Mac.\n\n2.2.1 Reading an R “.rds”-file\nThe readRDS() function is part of “base R”. This means it does not need a separate package. The {readr} package includes many functions for reading in data that do the same things as the base R packages, often with better defaults.\n\ndataset &lt;- readRDS(\"filepath/filename.rds\")\n\nor\n\ndataset &lt;- readr::read_rds(\"filepath/filename.rds\")\n\n\n\n2.2.2 Reading a Stata “.dta”-file\n\ndataset &lt;- haven::read_stata(\"filepath/filename.dta\")\n\n\n\n2.2.3 Importing an Excel file\nBecause data in Excel can take many different forms (different sheets, extra rows with information, etc.), there are many arguments to this function to make sure you are reading in the right data. It will default to the first sheet, with the first row used as column names.\n\ndataset &lt;- readxl::read_excel(\"filepath/filename.xlsx\")\n\n\n\n2.2.4 Importing a “.csv”-file\n\ndataset &lt;- read.csv(\"filepath/filename.csv\")\n\nor\n\ndataset &lt;- readr::read_csv(\"filepath/filename.csv\")\n\n\n\n2.2.5 Reading in a SAS file\n\nhaven::read_sas(\"filepath/filename.sas7bdat\",\n                \"filepath/catalog.sas7bcat\")"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#get-to-know-your-data",
    "href": "cheat_sheet/cheat_sheet.html#get-to-know-your-data",
    "title": "Basic R coding overview",
    "section": "2.3 Get to know your data",
    "text": "2.3 Get to know your data\nThere are a number of ways to summarize your dataset. The summary() function will print summary statistics for each variable.\n\nsummary(dataset)\n\nThe glimpse() function tells you the number of rows and columns, what type of variable each column contains, and shows you the first few observations.\n\ndplyr::glimpse(dataset)\n\nTo see what the entire dataset looks like, you can click on the name of the dataset in the Environment pane. This will open up a new tab with the dataset. You can also bring up this tab with:\n\nView(dataset)\n\nor\n\ntibble::view(dataset)\n\nTo compactly list the variable names:\n\nnames(dataset)\n\nTo count the number of observations (i.e. rows of data) in a dataset:\n\nnrow(dataset)\n\nTo count the number of observations in a subset of the data:\nCode for character variables:\n\nnrow(dataset[dataset$varname == \"Male\",])\n\nCode for numeric variables:\n\nnrow(dataset[dataset$varname == 1,])\n\nYou can also count the number of observations for each value of varname with:\n\ndplyr::count(dataset, varname)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#generate-quadratic-term",
    "href": "cheat_sheet/cheat_sheet.html#generate-quadratic-term",
    "title": "Basic R coding overview",
    "section": "3.1 Generate quadratic term",
    "text": "3.1 Generate quadratic term\n\ndataset$newvar &lt;- dataset$oldvar * dataset$newvar\n\nor\n\ndataset &lt;- mutate(dataset, newvar = oldvar * oldvar)\n\nYou can also create a quadratic term directly in a model itself, but it must be wrapped in I(): var + I(var^2) + other_vars ."
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#generate-a-categorical-variable-based-on-cut-points",
    "href": "cheat_sheet/cheat_sheet.html#generate-a-categorical-variable-based-on-cut-points",
    "title": "Basic R coding overview",
    "section": "3.2 Generate a categorical variable based on cut-points",
    "text": "3.2 Generate a categorical variable based on cut-points\nThere are a couple ways to create a categorical variable 'newvar' based on cutpoint values of a continuous variable 'oldvar' at cutpoints x and y.\n\nOne can use the cut() function to create a new categorical variable with cutpoints at the breaks = values. For example, say you have a variable with a minimum of 0 and a maximum of 100 with some missing values and you would like to make three categories defined by the values (0,x] (category 1), (x,y] (category 2), and (y,100] (category 3). For the breaks =argument, you will want to supply the left-hand breaks: a value lower than the minimum, x, y and then a value larger than the maximum. (You can use -Inf and Inf if you don’t know what the minimum and maximum are.) You can also use the include.lowest = and the right = arguments to change how the intervals are created.\n\ndataset$newvar &lt;- cut(dataset$newvar, \n                      breaks = c(-Inf, x, y, Inf))\n\nYou can also use case_when() if you want to be more explicit. For example, to generate a new categorical variable based on a set of cutpoints (ex. 40, 60, 80):\n\nlibrary(dplyr)\ndataset &lt;- mutate(dataset, newvar = case_when(\n  oldvar &lt; 40 ~ 0,\n  oldvar &gt;= 40 & oldvar &lt; 60 ~ 1,\n  oldvar &gt;= 60 & oldvar &lt; 80 ~ 2,\n  oldvar &gt;= 80 ~ 3\n))\n\nValues of oldvar that don’t meet any of the conditions will be assigned NA."
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#generate-quantiles",
    "href": "cheat_sheet/cheat_sheet.html#generate-quantiles",
    "title": "Basic R coding overview",
    "section": "3.3 Generate quantiles",
    "text": "3.3 Generate quantiles\nUse the quantile() function to generate a categorical variable based on quantile cutoffs. In the code below, set the number of desired quantiles (here, tertiles) by changing the value of nquantiles.\n\nnquantiles &lt;- 3\ndataset$newvar &lt;- cut(dataset$oldvar, \n                      breaks = quantile(dataset$oldvar, \n                                        probs = seq(0, 1, \n                                                    length.out = nquantiles + 1)), \n                      include.lowest=TRUE)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#generate-an-indicatordummy-variable",
    "href": "cheat_sheet/cheat_sheet.html#generate-an-indicatordummy-variable",
    "title": "Basic R coding overview",
    "section": "3.4 Generate an indicator/dummy variable",
    "text": "3.4 Generate an indicator/dummy variable\n\nYou generally don’t need to create indicator/dummy variables. In models, R will treat any factor variable as a series of indicator variables. If varname has numeric values, turn it into a factor variable (see next section):\n\n\ndataset$varname &lt;- factor(dataset$varname)\n\nand then use varname directly in a model.\n\nOne could also code the indicator/dummy variables manually using case_when().\nIn some scenarios, it may be helpful to generate the indicator variables used in a model with:\n\n\nnewvars &lt;- as.data.frame(model.matrix(~varname + othervar, \n                                      data = dataset))\n\nNote that this will also create an intercept (a column of ones) and will only contain the variables varname and othervar, no other variables from the dataset."
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#label-a-categorical-variable",
    "href": "cheat_sheet/cheat_sheet.html#label-a-categorical-variable",
    "title": "Basic R coding overview",
    "section": "3.5 Label a categorical variable",
    "text": "3.5 Label a categorical variable\nTo create a factor (categorical) variable, use the factor() function, with arguments levels = for the unique values and labels = for the names of those values. The labels wil be assigned to the level in the same order they are specified. For example, if oldvar has values 0, 1, and 2, which should be named “small” (0), “medium” (1), “large” (2):\n\ndataset$newvar &lt;- factor(dataset$oldvar, levels = c(0, 1, 2), \n                         labels = c(\"small\", \"medium\", \"large\"))\n\nThe reference level is always the first level (e.g. “small”). In models, R will treat character variables as factor variables, and the levels will be in alphabetical order. For example, if the variable in the example above was already labeled, but not a factor variable, putting it in a model or using the factor() function would result in levels “large”, “medium”, and “small” (“large” being the reference).\nTo determine whether a variable is already a factor variable, or whether it is a character variable (or another type), use:\n\nclass(dataset$varname)\n\nTo see the levels in order of a factor variable, use:\n\nlevels(dataset$varname)\n\nThe {forcats} package is designed to make working with categorical variables easier. If a variable has levels “large”, “medium”, and “small” and you want to change the order, you can use:\n\ndataset$newvar &lt;- forcats::fct_relevel(dataset$oldvar, \n                                       \"small\", \"medium\", \"large\")\n\nTo rename the levels “sm”, “md”, and “lg”:\n\ndataset &lt;- forcats::fct_recode(dataset$oldvar, \n                               \"sm\" = \"small\", \"md\" = \"medium\", \"lg\" = \"large\")\n\nIf the variable is numeric, you need to turn it into a character or factor variable before using fct_recode():\n\ndataset &lt;- forcats::fct_recode(as.character(dataset$oldvar), \n                               \"sm\" = \"0\", \"md\" = \"1\", \"lg\" = \"2\")"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#sorting-data",
    "href": "cheat_sheet/cheat_sheet.html#sorting-data",
    "title": "Basic R coding overview",
    "section": "3.6 Sorting data",
    "text": "3.6 Sorting data\nThe default of the arrange() function from the {dplyr} package is in ascending order.\n\ndataset &lt;- dplyr::arrange(dataset, varname)\n\nTo sort in descending order:\n\nlibrary(dplyr)\ndataset &lt;- arrange(dataset, desc(varname))\n\nYou can sort on multiple variables to arrange observations into ascending order based on varname1, and within each varname1 category one can sort into descending order by varname2.\n\nlibrary(dplyr)\ndataset &lt;- arrange(dataset, varname1, desc(varname2))"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#merge-two-datasets",
    "href": "cheat_sheet/cheat_sheet.html#merge-two-datasets",
    "title": "Basic R coding overview",
    "section": "3.7 Merge two datasets",
    "text": "3.7 Merge two datasets\nTo merge two datasets, use a _join() function from the {dplyr} package: left_join(), right_join(), full_join(). The functions differ by how they treat rows without a match in the “left-hand side” dataset and the “right-hand side” dataset.\nThis will keep all observations in dataset1 and merge only with observations from dataset2 with a matching id in dataset1:\n\nlibrary(dplyr)\ndataset3 &lt;- left_join(dataset1, dataset2, join_by(id))"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#keeping-and-dropping-observations",
    "href": "cheat_sheet/cheat_sheet.html#keeping-and-dropping-observations",
    "title": "Basic R coding overview",
    "section": "3.8 Keeping and dropping observations",
    "text": "3.8 Keeping and dropping observations\nTo create a dataset that is a subset of another dataset, use filter(). This code will retain all observations with both the age and sex requirement:\n\ndataset2 &lt;- dplyr::filter(dataset1, age &gt; 35, sex == \"F\")\n\nYou can also explicitly use logic operators such as & (and) and | (or). To retain observations that are either older than 35 or female (or both):\n\ndataset2 &lt;- dplyr::filter(dataset1, age &gt; 35 | sex == \"F\")"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#categorical-data-frequencies-tests-and-association-measures",
    "href": "cheat_sheet/cheat_sheet.html#categorical-data-frequencies-tests-and-association-measures",
    "title": "Basic R coding overview",
    "section": "4.1 Categorical data: frequencies, tests, and association measures",
    "text": "4.1 Categorical data: frequencies, tests, and association measures\n\n4.1.1 One-way frequency table\nOne can get a frequency table using the count() function.\n\ndplyr::count(dataset, varname)\n\nThe tabyl() function from the {janitor} package is also helpful for frequency tables because it will also add percentages by default to a one-way frequency table.\n\njanitor::tabyl(dataset, varname)\n\nFor a binary variable, you can use prop.test() or binom.test() (exact intervals) to get confidence intervals for the proportion of 1’s (or the “higher” level for a factor variable):\n\nprop.test(table(dataset$binary_var))\n\n\n\n4.1.2 RxC frequency tables\nOne can easily extend the functions above to cross-tabulate two categorical variables.\n\ndplyr::count(dataset, varname1, varname2)\njanitor::tabyl(dataset, varname1, varname2)\n\nTo get proportions when using tabyl():\n\nlibrary(janitor)\ntabyl(dataset, varname1, varname2) |&gt; adorn_percentages()\n\n\n\n4.1.3 Two-sample test of proportions\nTo compare proportions of varname2 stratified by varname1 and get a confidence interval for the difference in proportions;\n\nprop.test(table(dataset$varname1, dataset$varname2))\n\n\n\n4.1.4 Estimate measures of association\nThe {epitools} package contains functions for estimating various simple epidemiologic quantities. For example, to estimate a risk ratio (and the corresponding proportions):\n\nepitools::epitab(dataset$exposure, dataset$outcome, \n                 method = \"riskratio\")\n\n\n\n4.1.5 Stratified frequency tables\nYou can estimate any summary statistic of one variable (ex. varname1 or varname2) within different levels of a categorical variable (ex. categorical_variable):\n\ndplyr::summarize(dataset, mean_1 = mean(varname1), \n                 sd_2 = sd(varname2), .by = categorical_variable)\n\nFor two-way frequency tables (varname1 x varname2) stratified by a third variable (categoricalvariable):\n\njanitor::tabyl(dataset, varname1, varname2, categorical_variable)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#continuous-data-summary-statistics-visualization-and-statistical-tests",
    "href": "cheat_sheet/cheat_sheet.html#continuous-data-summary-statistics-visualization-and-statistical-tests",
    "title": "Basic R coding overview",
    "section": "4.2 Continuous data: summary statistics, visualization, and statistical tests",
    "text": "4.2 Continuous data: summary statistics, visualization, and statistical tests\n\n4.2.1 Measures of location and variance\nUse the summary command to obtain summary statistics for continuous data (mean, minimum, maximum, median, IQR):\n\nsummary(dataset$varname)\n\nYou can also estimate arbitrary summary statistics using dplyr::summarize():\n\ndplyr::summarize(dataset, mean = mean(varname), sd = sd(varname))\n\nOne can estimate the standard errors and 95% CI of the mean using the ci or ci means command. t.test() function:\n\nt.test(dataset$varname)\n\n\n\n4.2.2 Histogram\nA histogram graphic for continuous data:\n\nhist(dataset$age)\n\nWith the {ggplot2} package:\n\nggplot(dataset, aes(x = age)) + \n    geom_histogram() +\n    labs(title = \"Histogram of age\", \n         x = \"Age\")\n\n\n\n4.2.3 Box plots\nTo show a box-and-whisker plot of age and a box plot of age by a categorical variable (ex. sex):\n\nboxplot(dataset$age, dataset$sex)\n\n\nggplot(dataset, aes(y = age, x = sex)) + \n    geom_boxplot() +\n    labs(title = \"Boxplot of age by sex\", \n         x = \"Sex\", y = \"Age\")\n\n\n\n4.2.4 Scatterplot\nScatterplot of two continuous variables:\n\nplot(dataset$age, dataset$bmi)\n\n\nggplot(dataset, aes(y = age, x = bmi)) + \n    geom_point() +\n    labs(x = \"Age\", y = \"BMI\")\n\n\n\n4.2.5 Statistical Tests\nTo conduct a two-sample T-test (continuous variable by a binary variable), use the t.test() function with the var.equal = FALSE argument if desired:\n\nt.test(continuous_var ~ categorical_var, \n       data = dataset, var.equal = FALSE)\n\nTo conduct a one-way ANOVA (test differences of two or more means), use the aov() function:\n\naov(continuous_var ~ categorical_var, data = dataset)\n\nTo conduct a non-parametric test Wilcoxon Rank-sum test (aka Mann-Whitney U test), use the wilcox.test() function:\n\nwilcox.test(continuous_var ~ categorical_var, data = dataset)\n\n\n\n4.2.6 Correlation coefficients\nOne can estimate correlation coefficients using the cor() function. The default is Pearson; one can estimate the Spearman correlation coefficients using the method = \"spearman\" argument:\n\ncor(dataset[, c(\"varname1\", \"varname2\", \"varname3\")], \n    method = \"spearman\")\n\nYou can also provide two vectors if a single correlation is desired. For confidence intervals and hypothesis tests, use cor.test().\n\ncor.test(dataset$varname1, dataset$varname2)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#logistic-regression",
    "href": "cheat_sheet/cheat_sheet.html#logistic-regression",
    "title": "Basic R coding overview",
    "section": "5.1 Logistic Regression",
    "text": "5.1 Logistic Regression\n\n5.1.1 Using continuous or binary variables\nFit a logistic regression model:\n\nmodel &lt;- glm(outcome ~ exposure + var1 + var2, \n             data = dataset, family = binomial())\n\nCode to output the beta coefficients:\n\ncoef(model)\n\nCode to output the odds ratios:\n\nexp(coef(model))\n\nCoefficients, standard errors, p-values:\n\nsummary(model)\n\nConfidence intervals:\n\nconfint(model)\n\nThe {broom} package is helpful for getting model output:\n\nbroom::tidy(model, exponentiate = TRUE, conf.int = TRUE)\n\n\n\n5.1.2 Using indicator variables\nR automatically creates indicator variables for factor or character variables (see previous section). To force it to create indicator variables for a numeric variable, you can use factor():\n\nmodel &lt;- glm(outcome ~ exposure + factor(var1) + var2, \n             data = dataset, family = binomial())\n\nTo change the referent group, you can use fct_relevel() to move a new level to be the first level (the other levels will stay in their original order, unless you include them):\n\ndataset$newvar &lt;- forcats::fct_relevel(dataset$oldvar, \"ref\")\nmodel &lt;- glm(outcome ~ exposure + newvar, \n             data = dataset, family = binomial())\n\n\n\n5.1.3 Stratified Logistic Regression\nTo fit a logistic regression model within levels of categorical_var:\n\nlibrary(dplyr)\nmodels &lt;- dataset |&gt; \n  group_by(categorical_var) |&gt; \n  group_map(~glm(outcome ~ exposure, data = .x))"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#linear-regression",
    "href": "cheat_sheet/cheat_sheet.html#linear-regression",
    "title": "Basic R coding overview",
    "section": "5.2 Linear Regression",
    "text": "5.2 Linear Regression\nOne can conduct a linear regression model using either the lm() function or the glm() function with family = gaussian(). All of the same functions work on these models to extract model output.\n\nmodel &lt;- lm(outcome ~ exposure + var1 + var1)\nbroom::tidy(model, conf.int = TRUE)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#survival-data",
    "href": "cheat_sheet/cheat_sheet.html#survival-data",
    "title": "Basic R coding overview",
    "section": "5.3 Survival Data",
    "text": "5.3 Survival Data\n\n5.3.1 Set-up\nThe {survival} package is used for this entire section.\n\nlibrary(survival)\n\nWithin that package, the Surv() function is used to “create” the outcome and is used in other functions:\n\nSurv(time_to_outcome, outcome)\n\n\n\n5.3.2 Graphs\nKaplan-Meier curves overall:\n\nkm &lt;- survfit(Surv(time_to_outcome, outcome) ~ 1, \n              data = dataset)\nplot(km)\n\nKM curves by exposure groups:\n\nkm &lt;- survfit(Surv(time_to_outcome, outcome) ~ exposure, \n              data = dataset)\nplot(km)\n\nTo add 95% confidence intervals and censoring marks to the figure:\n\nplot(km, conf.int = TRUE, mark.time = TRUE)\n\nLog negative-log survivor plots:\n\nplot(km, fun = \"cloglog\")\n\nThe {survminer} package is useful for creating survival curves for publication and can also include risk tables:\n\nsurvminer::ggsurvplot(km, risk.table = TRUE)\n\n\n\n5.3.3 Summary statistics\nTo see survivor function at various time points (ex. 30, 60, 90 days):\n\nsummary(km, times = c(30, 60, 90))\n\nYou can also use the tidy() function to extract the estimates and confidence intervals over all times in a nicer format:\n\nbroom::tidy(km)\n\nTo get median and other percentile survival times with confidence intervals:\n\nquantile(km, probs = c(0.25, 0.5, 0.75))\n\n\n\n5.3.4 Statistical tests\nLog-rank test:\n\nsurvdiff(Surv(time_to_outcome, outcome) ~ exposure, \n         data = dataset)\n\nSee the {survminer} vignette for details on plotting survival curves with p-values from weighted log-rank tests (here, Tarone-Ware):\n\nsurvminer::ggsurvplot(km, data = dataset, \n                      pval = TRUE, pval.method = TRUE,\n                      log.rank.weights = \"sqrtN\",\n                      pval.method.coord = c(3, 0.1),\n                      pval.method.size = 4)\n\n\n\n5.3.5 Cox Regression\nOne can conduct a Cox regression model using the coxph() function from the {survival} package.\n\ncox &lt;- coxph(Surv(time_to_outcome, outcome) ~ exposure, \n             data = dataset)\n\nThe functions from the logistic regression section can be used to extract model output.\nCompeting Risk Analysis: In carrying out a competing risk analysis, the “outcome” variable can take on three values. There must be a value for the actual event of interest (outcome=1); a value for censoring (outcome=0); and a value for the competing risk event (outcome=2).\n\nfg_data &lt;- finegray(Surv(time_to_outcome, outcome) ~ exposure, \n                    data = dataset)\nfg_model &lt;- coxph(Surv(fgstart, fgstop, fgstatus) ~ exposure, \n                  weight = fgwt, data = fg_data)"
  },
  {
    "objectID": "cheat_sheet/cheat_sheet.html#goodness-of-fit-statistics",
    "href": "cheat_sheet/cheat_sheet.html#goodness-of-fit-statistics",
    "title": "Basic R coding overview",
    "section": "5.4 Goodness of Fit Statistics",
    "text": "5.4 Goodness of Fit Statistics\nTo get the log Likelihood/AIC/BIC for the most recent regression model:\n\nloglik(model)\nAIC(model)\nBIC(model)\n\nTo run a likelihood ratio test comparing two nested models:\n\nlmtest::lrtest(mod_full, mod_nested)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R",
    "section": "",
    "text": "June 6-9, 2023\n\n2-5 pm\n\n\nFaculty\nLouisa Smith\nAssistant Professor\nDepartment of Health Sciences, Northeastern University\nl.smith@northeastern.edu\nOffice Hours: 1-2 pm Kresge 201\n\nTeaching Assistant\nSabine Friedrich\nsfriedrich@hsph.harvard.edu\nOffice hours: 12-1 pm Kresge 201"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "pre_work/index.html",
    "href": "pre_work/index.html",
    "title": "Pre-work",
    "section": "",
    "text": "Install R and RStudio\n\nDownload R from CRAN. Choose the link at the top that corresponds to your operating system.  Unless you downloaded R within the past month or two, do so again – you want the most up-to-date version (≥ R 4.3) for this class.\nDownload RStudio (step 2 on that page – you already completed step 1 above!). It should automatically recognize your operating system, but if not, choose the correct link at the bottom.\n\nIf you have a Mac, make sure you choose correctly between the Apple Silicon (M1/M2) and Intel options.Which version of RStudio you have is not as important, but it’s nice to stay up-to-date for the newest features!\n\nVideo\nOpen the slides in a new tab here or follow along below.\n(P.S. Sorry, I didn’t realize the video of my face would be in the screen instead of off to the side!)\n\n\n\n\n\n\nReadings\n\nSections 1.4-1.5 of R for Data Science. Run the code in your RStudio console as you go.\nChapter 3 of R for Data Science. Again, run the code in your RStudio console as you read. Try the exercises.\nOptional, but helpful: Chapter 2 of Hands-On Programming with R. For the purposes of this class, we will necessarily skip some of the R basics to focus on the skills you’ll need most. This is a good resource if you want to learn more about them, so it’s highly recommended, you just don’t need to master it as part of your pre-work.\n\nIn particular, make sure you install the packages in the text.If you’re wondering what happened to chapter 2, we’ll be doing that one together!\n\nHomework\nComplete the following exercises, showing your code for each. You can download the homework as a Word document here or on Canvas. Please copy and paste your code and answers into the document and submit on Canvas.\n\nInstall R and RStudio as well as the packages described in Section 1.4 of of R for Data Science. Paste the code you used to install those packages below.\nCreate a vector named temp with the average low temperatures in December for London, Shanghai, Sydney, Boston, Mexico City and Johannesburg which are 40, 38, 64, 28, 42 and 57° Fahrenheit.\nCreate a second vector with the city names called city.\nUse the setNames() function to assign the city names to the corresponding temperatures using the two objects create above. (Hint: help(setNames)). You should overwrite your original temp vector with the named vector. Print the temp vector.\nRecall that you can use the [] operator directly following a vector name to select specific values contained within that vector (e.g. temp[1] should return 40). Use this [] operator and the sum() function to calculate the sum of the temperatures for Sydney, Mexico City and Johannesburg.\nCreate a vector of all positive even numbers smaller than 75 using the seq() function. (Hint: help(seq))\nCreate a vector of numbers. Let the first value of the vector be 4, with a maximum value &lt; 80, adding numbers in increments of 2/3. How many elements are in this vector?\nUsing your answer to the previous question, find another solution to create the same vector as the previous question."
  },
  {
    "objectID": "day_1/index.html",
    "href": "day_1/index.html",
    "title": "Day 1",
    "section": "",
    "text": "Download some exercises to go along with these slides here.\nHere is the R script containing the code we ran in class.\nOpen the slides in a new tab here.\n\n\n\nOpen the slides in a new tab here.\n\n\n\nOpen the slides in a new tab here."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "R for Data Science Slack learning group: https://www.rfordatasci.com/about/\nMore extensive Harvard course covering R and other aspects of computing: https://id529.github.io/\nRMarkdown book: https://bookdown.org/yihui/rmarkdown/\nQuarto: https://quarto.org/\nInstalling LateX to generate PDFs with RMarkdown or Quarto: https://bookdown.org/yihui/rmarkdown-cookbook/install-latex.html\nCheat sheets: https://posit.co/resources/cheatsheets/"
  }
]