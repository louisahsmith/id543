{
  "hash": "7bef13ac4e8e37203f8bddfa21468829",
  "result": {
    "markdown": "---\ntitle: \"Data wrangling\"\nformat: \n  revealjs:\n    theme: \n      - ../../www/custom.scss\norder: 1\nexecute: \n  echo: true\n---\n\n\n\n## Making variables in \"Base R\" \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy$region_cat <- factor(nlsy$region)\nnlsy$income <- round(nlsy$income)\nnlsy$age_bir_cent <- nlsy$age_bir - mean(nlsy$age_bir)\nnlsy$index <- 1:nrow(nlsy)\nnlsy$slp_wkdy_cat <- ifelse(nlsy$sleep_wkdy < 5, \"little\",\n                            ifelse(nlsy$sleep_wkdy < 7, \"some\",\n                                   ifelse(nlsy$sleep_wkdy < 9, \"ideal\",\n                                          ifelse(nlsy$sleep_wkdy < 12, \"lots\", NA)\n                                   )\n                            )\n)\n```\n:::\n\n\n\n\n## Very quickly your code can get overrun with dollar signs (and parentheses, and arrows)\n![](../../img/ugly-code.png)\n\n## Cleaner way to make new variables: `mutate()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# mutate() is from dplyr\nnlsy <- mutate(nlsy, # dataset\n               # new variables\n               region_cat = factor(region, labels = c(\"Northeast\", \"North Central\", \"South\", \"West\")), \n               income = round(income),\n               age_bir_cent = age_bir - mean(age_bir),\n               index = row_number()\n               # could make as many as we want....\n)\n```\n:::\n\n\n#### We can refer to variables within the same dataset (`region`, `income`, `age_bir`) without the `$` notation\n\n## `mutate()` tips and tricks\n\nYou still need to store your dataset somewhere, so make sure to include the assignment arrow\n\n- Good practice to make new copies with different names as you go along\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy_w_cats <- mutate(nlsy, # dataset\n                      region_cat = factor(region),\n                      sex_cat = factor(sex),\n                      race_eth_cat = factor(race_eth))\n\nnlsy_clean <- mutate(nlsy_w_cats, # dataset\n                     region_cat = fct_recode(region_cat,\n                                             \"Northeast\" = \"1\",\n                                             \"North Central\" = \"2\",\n                                             \"South\" = \"3\",\n                                             \"West\" = \"4\"),\n                     sex_cat = fct_relevel(sex_cat,\n                                           \"Female\", \"Male\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `sex_cat = fct_relevel(sex_cat, \"Female\", \"Male\")`.\nCaused by warning:\n! 2 unknown levels in `f`: Female and Male\n```\n:::\n:::\n\n\n\n\n## `mutate()` tips and tricks\n\n- You can refer immediately to variables you just made:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy_new <- mutate(nlsy,\n                   age_bir_cent = age_bir - mean(age_bir),\n                   age_bir_stand = age_bir_cent / sd(age_bir_cent)\n)\n```\n:::\n\n\n\n::: callout-tip\n\"Chunk\" your work on the same/similar variables so you can keep track of how a variable is derived.\n:::\n\n## My favorite R function: `case_when()`\n\nI used to write endless strings of `ifelse()` statements\n\n- If A is TRUE, then B; if not, then if C is true, then D; if not, then if E is true, then F; if not, ...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy <- mutate(nlsy,\n               ifelse(sleep_wkdy < 5,  \"little\", \n                      ifelse(sleep_wkdy < 7, \"some\", \n                             ifelse(sleep_wkdy < 9, \"ideal\", \n                                    ifelse(sleep_wkdy < 12, \"lots\", NA)))))\n```\n:::\n\n\n\n![](../../img/if-else.png)\n\nThis can be extremely hard to follow!\n\n## `case_when()` syntax\n\n- Ask a question (i.e., something that will give `TRUE` or `FALSE`) on the left-hand side of a `~`\n- `sleep_wkdy < 5 ~`\n- If `TRUE`, variable will take on value of whatever is on the right-hand side of the `~`\n- `~ \"little\"`\n- Proceeds in order ... if TRUE, takes that value and **stops**\n- If you want some default value, you can end with `.default = {something}`, which every observation will get if everything else is `FALSE`\n- `.default = NA` is the default default\n\n\n## `case_when()` combines a lot of \"if-else\" statements\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy <- mutate(nlsy, slp_cat_wkdy = \n                 case_when(sleep_wkdy < 5 ~ \"little\",\n                           sleep_wkdy < 7 ~ \"some\",\n                           sleep_wkdy < 9 ~ \"ideal\",\n                           sleep_wkdy < 12 ~ \"lots\",\n                           .default = NA\n                 )\n)\n\ncount(nlsy, sleep_wkdy, slp_cat_wkdy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 × 3\n   sleep_wkdy slp_cat_wkdy     n\n        <dbl> <chr>        <int>\n 1          0 little           1\n 2          2 little           4\n 3          3 little          14\n 4          4 little          48\n 5          5 some           136\n 6          6 some           326\n 7          7 ideal          357\n 8          8 ideal          269\n 9          9 lots            32\n10         10 lots            14\n11         11 lots             1\n12         12 <NA>             2\n13         13 <NA>             1\n```\n:::\n:::\n\n\n\n## `case_when()` example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy <- mutate(nlsy, total_sleep = \n                 case_when(\n                   sleep_wknd > 8 & sleep_wkdy > 8 ~ 1,\n                   sleep_wknd + sleep_wkdy > 15 ~ 2,\n                   sleep_wknd - sleep_wkdy > 3 ~ 3\n                 )\n)\n```\n:::\n\n\n\n- Which value would someone with `sleep_wknd = 8` and `sleep_wkdy = 4` go? \n- What about someone with  `sleep_wknd = 11` and `sleep_wkdy = 4`? \n- What about someone with `sleep_wknd = 7` and `sleep_wkdy = 7`?\n\n# Exercises\n\n## Selecting the variables you want\n\n- We've made tons of new variables!\n- You don't want to keep them all!\n- Luckily there's an easy way to select the variables you want: `select()`!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy_subset <- select(nlsy, id, income, eyesight, sex, region)\nnlsy_subset\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 5\n      id income eyesight   sex region\n   <dbl>  <dbl>    <dbl> <dbl>  <dbl>\n 1     3  22390        1     2      1\n 2     6  35000        2     1      1\n 3     8   7227        2     2      1\n 4    16  48000        3     2      1\n 5    18   4510        3     1      3\n 6    20  50000        2     2      1\n 7    27  20000        1     2      1\n 8    49  23900        1     2      1\n 9    57  23289        2     2      1\n10    67  35000        1     1      1\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n\n## `select()` syntax\n\n- Like `mutate()`, the first argument is the dataset you want to select from\n- Then you can just list the variables you want!\n- Or you can list the variables you *don't* want, preceded by an exclamation point (`!`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(nlsy_subset, !c(id, region))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 3\n   income eyesight   sex\n    <dbl>    <dbl> <dbl>\n 1  22390        1     2\n 2  35000        2     1\n 3   7227        2     2\n 4  48000        3     2\n 5   4510        3     1\n 6  50000        2     2\n 7  20000        1     2\n 8  23900        1     2\n 9  23289        2     2\n10  35000        1     1\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n\n## `select()` syntax\n\n- There are also a lot of \"helpers\"!\n- `var1:var10` (consecutively placed variables)\n- `all_of()`/`any_of()`\n- `starts_with()`\n- `ends_with()`\n- `contains()`\n- `matches()` (like contains, but for regular expressions)\n- `num_range()` (for patterns like `x01`, `x02`, ...)  \n- `everything()`\n- `where(is.factor)` (or anything else)\n\n## `all_of()`\n\nNotice that the variable names we used in `select()` weren't in quotation marks.\n\nLet's say you have a vector of column names that you want. Then you can use `all_of()` to choose them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols_I_want <- c(\"age_bir\", \"nsibs\", \"region\")\nselect(nlsy, all_of(cols_I_want))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 3\n   age_bir nsibs region\n     <dbl> <dbl>  <dbl>\n 1      19     3      1\n 2      30     1      1\n 3      17     7      1\n 4      31     3      1\n 5      19     2      3\n 6      30     2      1\n 7      27     1      1\n 8      24     6      1\n 9      21     1      1\n10      36     1      1\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n\nIf you don't want an error if they don't exist, use `any_of()`.\n\n## `starts_with`, `ends_with`\n\nVariables won't be repeated even if they meet multiple criteria\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(nlsy, starts_with(\"sleep\"), ends_with(\"d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 3\n   sleep_wkdy sleep_wknd    id\n        <dbl>      <dbl> <dbl>\n 1          5          7     3\n 2          6          7     6\n 3          7          9     8\n 4          6          7    16\n 5         10         10    18\n 6          7          8    20\n 7          8          8    27\n 8          8          8    49\n 9          7          8    57\n10          8          8    67\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n\n## `starts_with`, `ends_with`\n\nUse `&` in between multiple criteria if they have to meet *all* of them\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(nlsy, starts_with(\"sleep\") & ends_with(\"d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 1\n   sleep_wknd\n        <dbl>\n 1          7\n 2          7\n 3          9\n 4          7\n 5         10\n 6          8\n 7          8\n 8          8\n 9          8\n10          8\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n\n## `where()`\n\nYou can use these helpers to rearrange variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(nlsy, id, where(is.factor), where(is.numeric), everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 24\n      id eyesight_cat glasses_cat        race_eth_cat sex_cat region_cat glasses\n   <dbl> <fct>        <fct>              <fct>        <fct>   <fct>        <dbl>\n 1     3 Excellent    Doesn't wear glas… Non-Black, … Female  Northeast        0\n 2     6 Very Good    Wears glasses/con… Non-Black, … Male    Northeast        1\n 3     8 Very Good    Doesn't wear glas… Non-Black, … Female  Northeast        0\n 4    16 Good         Wears glasses/con… Non-Black, … Female  Northeast        1\n 5    18 Good         Doesn't wear glas… Non-Black, … Male    South            0\n 6    20 Very Good    Wears glasses/con… Non-Black, … Female  Northeast        1\n 7    27 Excellent    Doesn't wear glas… Non-Black, … Female  Northeast        0\n 8    49 Excellent    Wears glasses/con… Non-Black, … Female  Northeast        1\n 9    57 Very Good    Wears glasses/con… Non-Black, … Female  Northeast        1\n10    67 Excellent    Doesn't wear glas… Non-Black, … Male    Northeast        0\n# ℹ 1,195 more rows\n# ℹ 17 more variables: eyesight <dbl>, sleep_wkdy <dbl>, sleep_wknd <dbl>,\n#   nsibs <dbl>, samp <dbl>, race_eth <dbl>, sex <dbl>, region <dbl>,\n#   income <dbl>, res_1980 <dbl>, res_2002 <dbl>, age_bir <dbl>,\n#   age_bir_cent <dbl>, index <int>, total_sleep <dbl>, slp_cat_wkdy <chr>,\n#   slp_wkdy_cat <chr>\n```\n:::\n:::\n\n\n\n# Exercises\n\n## Subsetting data\n\nWe usually don't do an analysis in an *entire* dataset. We usually apply some eligibility criteria to find the people who we will analyze. One function we can use to do that in R is `filter()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwear_glasses <- filter(nlsy, glasses == 1)\n\nnrow(wear_glasses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 624\n```\n:::\n\n```{.r .cell-code}\nsummary(wear_glasses$glasses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      1       1       1       1       1       1 \n```\n:::\n:::\n\n\n\n## `filter()` syntax\n\n::: smaller\n- Like the other functions, we give `filter()` the dataset first, then we give it a series of criteria that we want to subset our data on. \n- As with `case_when()`, these criteria should be questions with `TRUE`/`FALSE` answers. We'll keep all those rows for which the answer is `TRUE`.\n- If there are multiple criteria, we can connect them with `&` or just by separating with commas, and we'll get back only the rows that answer `TRUE` to all of them.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyesno_glasses <- filter(nlsy, glasses == 0, glasses == 1)\nnrow(yesno_glasses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nglasses_great_eyes <- filter(nlsy, glasses == 0, eyesight == 1)\nnrow(glasses_great_eyes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 220\n```\n:::\n:::\n\n\n\n## Logicals in R\n\nWhen we used `case_when()`, we got `TRUE`/`FALSE` answers when we asked whether a variable was `>` or `<` some number, for example.\n\nWhen we want to know if something is\n\n- equal: `==`\n- not equal: `!=`\n- greater than or equal to: `>=`\n- less than or equal to: `<=`\n\nWe also can ask about multiple conditions with `&` (and) and `|` (or).\n\n## Or statements\n\nTo get the extreme values of eyesight (1 and 5), we would do something like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextreme_eyes <- filter(nlsy, eyesight == 1 | \n                         eyesight == 5)\ntable(extreme_eyes$eyesight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  1   5 \n474  19 \n```\n:::\n:::\n\n\nWe could of course do the same thing with a factor variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_regions <- filter(nlsy, region_cat == \"Northeast\" | \n                         region_cat == \"South\")\ntable(some_regions$region_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    Northeast North Central         South          West \n          206             0           411             0 \n```\n:::\n:::\n\n\n\n\n## Multiple \"or\" possibilities\n\nOften we have a number of options for one variable that would meet our eligibility criteria. R's special `%in%` function comes in handy here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_regions <- filter(nlsy, region_cat %in% \n                         c(\"South\", \"West\", \"Northeast\"))\ntable(more_regions$region_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    Northeast North Central         South          West \n          206             0           411           255 \n```\n:::\n:::\n\n\n\nIf the variable's value is any one of those values, it will return `TRUE`.\n\n## More `%in%`\n\nThis is just a regular R function that works outside of the `filter()` function, of course!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 %in% c(4, 6, 7, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5 %in% c(4, 6, 7, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\n## Opposite of `%in%`\n\nWe can't say \"not in\" with the syntax `%!in%` or something like that. We have to put the `!` *before* the question to basically make it the opposite of what it otherwise would be.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!7 %in% c(4, 6, 7, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n!5 %in% c(4, 6, 7, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnorthcentralers <- filter(nlsy, \n                          !region_cat %in% \n                            c(\"South\", \"West\", \"Northeast\"))\ntable(northcentralers$region_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    Northeast North Central         South          West \n            0           333             0             0 \n```\n:::\n:::\n\n\n\n## Other questions\n\nR offers a number of shortcuts to use when determining whether values meet certain criteria:\n\n- `is.na()`: is it a missing value? \n- `is.finite()` / `is.infinite()`: when you might have infinite values in your data\n- `is.factor()`: asks whether some variable is a factor\n\nYou can find lots of these if you tab-complete `is.` or `is_` (the latter are tidyverse versions). Most you will never find a use for!\n\n## Putting it all together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- filter(nlsy, \n                  age_bir_cent < 1,\n                  sex != 1,\n                  nsibs %in% c(1, 2, 3),\n                  !is.na(slp_cat_wkdy))\n\nsummary(select(my_data, age_bir_cent, sex, nsibs, slp_cat_wkdy))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age_bir_cent          sex        nsibs       slp_cat_wkdy      \n Min.   :-9.4481   Min.   :2   Min.   :1.000   Length:207        \n 1st Qu.:-5.4481   1st Qu.:2   1st Qu.:2.000   Class :character  \n Median :-4.4481   Median :2   Median :2.000   Mode  :character  \n Mean   :-3.8249   Mean   :2   Mean   :2.174                     \n 3rd Qu.:-1.4481   3rd Qu.:2   3rd Qu.:3.000                     \n Max.   : 0.5519   Max.   :2   Max.   :3.000                     \n```\n:::\n:::\n\n\n\n## Putting it all together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noth_dat <- filter(nlsy, \n                  (age_bir_cent < 1) &\n                    (sex != 1 | nsibs %in% c(1, 2, 3)) &\n                    !is.na(slp_cat_wkdy))\n\nsummary(select(oth_dat, age_bir_cent, sex, nsibs, slp_cat_wkdy))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age_bir_cent           sex            nsibs        slp_cat_wkdy      \n Min.   :-10.4481   Min.   :1.000   Min.   : 0.000   Length:602        \n 1st Qu.: -6.4481   1st Qu.:2.000   1st Qu.: 2.000   Class :character  \n Median : -3.4481   Median :2.000   Median : 3.000   Mode  :character  \n Mean   : -3.8518   Mean   :1.817   Mean   : 3.982                     \n 3rd Qu.: -1.4481   3rd Qu.:2.000   3rd Qu.: 5.000                     \n Max.   :  0.5519   Max.   :2.000   Max.   :16.000                     \n```\n:::\n:::\n\n\n\n# Exercises\n\n## Your code might start to look like this\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy2 <- mutate(nlsy, \n                only = case_when(\n                  nsibs == 0 ~ \"yes\",\n                  .default = \"no\"))\nnlsy3 <- select(nlsy2, id, contains(\"sleep\"), only)\nonly_kids <- filter(nlsy3, only == \"yes\")\nonly_kids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 × 5\n      id sleep_wkdy sleep_wknd total_sleep only \n   <dbl>      <dbl>      <dbl>       <dbl> <chr>\n 1   458          7          8          NA yes  \n 2   653          6          7          NA yes  \n 3  1101          7          8          NA yes  \n 4  1166          5          6          NA yes  \n 5  2163          7          8          NA yes  \n 6  2442          7          9           2 yes  \n 7  2545          8          8           2 yes  \n 8  3036          5          8          NA yes  \n 9  3194          7          7          NA yes  \n10  3538          5          5          NA yes  \n# ℹ 20 more rows\n```\n:::\n:::\n\n\n\n## Sequence of functions\n\n:::: {.columns}\n\n::: {.column width=\"49%\"}\nIn any data management and/or analysis task, we perform a series of functions to the data until we get some object we want.\n\nSometimes this can be hard to read/keep track of.\n\n:::\n\n::: {.column width=\"48%\"}\n\n::: {.center}\n![](../../img/todolist.jpg)\n\n:::\n\n:::\n::::\n\n## The pipe\n\n:::: {.columns}\n\n::: {.column width=\"49%\"}\nIf you have experience with unix programming, you may be familiar with the version of the pipe there: `|`.\n\nStarting with R version 4.1, R has its own pipe: `|>`\n\n:::\n::: {.column width=\"48%\"}\n::: {.center}\n![](../../img/pipe.png)\n:::\nThe original pipe function `%>%` has been part of the tidyverse for a while and is originally from the `magrittr` package, named after [René Magritte](https://en.wikipedia.org/wiki/The_Treachery_of_Images)\n:::\n::::\n\n## We use the pipe to chain together steps\n\nIt's like a recipe for our dataset.^[Example from [Lise Vaudor](http://perso.ens-lyon.fr/lise.vaudor/utiliser-des-pipes-pour-enchainer-des-instructions/)]\n![](../../img/recipe.jpg)\n\n## Instead of successive command lines\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy2 <- mutate(nlsy, \n                only = case_when(nsibs == 0 ~ \"yes\", \n                                 .default = \"no\"))\nnlsy3 <- select(nlsy2, id, contains(\"sleep\"), only)\nonly_kids <- filter(nlsy3, only == \"yes\")\n```\n:::\n\n\n\nor all-in-one\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nonly_kids <- filter(select(mutate(nlsy, only = case_when(nsibs == 0 ~ \"yes\", .default = \"no\")), id, contains(\"sleep\"), only), only == \"yes\")\n```\n:::\n\n\n\n## It's like reading a story (or nursery rhyme!)\n\n:::: columns\n::: {.column width=70%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_foo <- little_bunny()\nbop_on(\n  scoop_up(\n    hop_through(foo_foo, forest),\n    field_mouse),\n  head)\n```\n:::\n\n\n\n### vs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_foo |> \n  hop_through(forest) |> \n  scoop_up(field_mouse) |> \n  bop_on(head)\n```\n:::\n\n\n:::\n\n::: {.column width=30%}\n![](../../img/bunny.jpg)\n:::\n::::\n::: aside\nExample from [Hadley Wickham](https://t.co/Qn4B7Kna2D?amp=1)\n:::\n\n## A natural order of operations\n\n:::: columns\n::: {.column width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleave_house(\n  get_dressed(\n    get_out_of_bed(\n      wake_up(me))))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nme <- wake_up(me)\nme <- get_out_of_bed(me)\nme <- get_dressed(me)\nme <- leave_house(me)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nme  |> \n  wake_up()  |> \n  get_out_of_bed()  |> \n  get_dressed()  |> \n  leave_house()\n```\n:::\n\n\n:::\n\n::: {.column width=50%}\n![](../../img/friday.png)\n:::\n::::\n::: aside\nExample from [Andrew Heiss](https://twitter.com/andrewheiss/status/1173743447171354624?s=20)\n:::\n\n## Using pipes with functions we already know {.smaller}\n\n:::: columns\n::: {.column width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy2 <- mutate(nlsy, only = case_when(\n  nsibs == 0 ~ \"yes\",\n  .default = \"no\"))\nnlsy3 <- select(nlsy2, \n                id, contains(\"sleep\"), only)\nonly_kids <- filter(nlsy3, only == \"yes\")\nonly_kids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 × 5\n      id sleep_wkdy sleep_wknd total_sleep only \n   <dbl>      <dbl>      <dbl>       <dbl> <chr>\n 1   458          7          8          NA yes  \n 2   653          6          7          NA yes  \n 3  1101          7          8          NA yes  \n 4  1166          5          6          NA yes  \n 5  2163          7          8          NA yes  \n 6  2442          7          9           2 yes  \n 7  2545          8          8           2 yes  \n 8  3036          5          8          NA yes  \n 9  3194          7          7          NA yes  \n10  3538          5          5          NA yes  \n# ℹ 20 more rows\n```\n:::\n:::\n\n\n:::\n\n:::{.column width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nonly_kids <- nlsy |> \n  mutate(only = case_when(\n    nsibs == 0 ~ \"yes\",\n    TRUE ~ \"no\")) |> \n  select(id, contains(\"sleep\"), only) |> \n  filter(only == \"yes\")\nonly_kids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 × 5\n      id sleep_wkdy sleep_wknd total_sleep only \n   <dbl>      <dbl>      <dbl>       <dbl> <chr>\n 1   458          7          8          NA yes  \n 2   653          6          7          NA yes  \n 3  1101          7          8          NA yes  \n 4  1166          5          6          NA yes  \n 5  2163          7          8          NA yes  \n 6  2442          7          9           2 yes  \n 7  2545          8          8           2 yes  \n 8  3036          5          8          NA yes  \n 9  3194          7          7          NA yes  \n10  3538          5          5          NA yes  \n# ℹ 20 more rows\n```\n:::\n:::\n\n\n:::\n::::\n\n## Pipes replace the first argument of the next function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mutate)\nhelp(select)\nhelp(filter)\n```\n:::\n\n\n### Usage\n\n`mutate(.data, ...)`\n\n`select(.data, ...)`\n\n`filter(.data, ...)`\n\n## Pipes replace the first argument of the next function\n\n\n:::: {.columns}\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy2 <- mutate(nlsy, \n                only = \n                  case_when(\n                    nsibs == 0 ~ \"yes\",\n                    .default = \"no\"))\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nonly_kids <- nlsy  |> \n  mutate(only = \n           case_when(\n             nsibs == 0 ~ \"yes\",\n             .default = \"no\"))\n```\n:::\n\n\n\n:::\n\n::::\n\n## Pipes replace the first argument of the next function\n\n\n:::: {.columns}\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy2 <- mutate(nlsy, \n                only = \n                  case_when(\n                    nsibs == 0 ~ \"yes\",\n                    .default = \"no\"))\nnlsy3 <- select(nlsy2, \n                id, contains(\"sleep\"),\n                only)\nonly_kids <- filter(nlsy3,\n                    only == \"yes\")\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nonly_kids <- nlsy  |> \n  mutate(only = \n           case_when(\n             nsibs == 0 ~ \"yes\",\n             TRUE ~ \"no\"))  |> \n  select(id,\n         contains(\"sleep\"),\n         only)  |> \n  filter(only == \"yes\")\n```\n:::\n\n\n:::\n::::\n\n# Exercises\n\n",
    "supporting": [
      "wrangling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}