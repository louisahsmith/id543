{
  "hash": "4d5495390d2a9b576eccdf7538fdc768",
  "result": {
    "markdown": "---\ntitle: \"Grouping and summarizing data\"\nformat: \n  revealjs:\n    theme: \n      - ../../www/custom.scss\norder: 2\nexecute: \n  echo: true\n---\n\n\n## Summary statistics\n\nWe can get certain summary statistics about our data with `summary()`, which we can use either on an entire dataframe or on a single variable\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nlsy_sleep)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id          sleep_wkdy       sleep_wknd        age_bir     \n Min.   :    3   Min.   : 0.000   Min.   : 0.000   Min.   :13.00  \n 1st Qu.: 2317   1st Qu.: 6.000   1st Qu.: 6.000   1st Qu.:19.00  \n Median : 4744   Median : 7.000   Median : 7.000   Median :22.00  \n Mean   : 5229   Mean   : 6.643   Mean   : 7.267   Mean   :23.45  \n 3rd Qu.: 7937   3rd Qu.: 8.000   3rd Qu.: 8.000   3rd Qu.:27.00  \n Max.   :12667   Max.   :13.000   Max.   :14.000   Max.   :52.00  \n      sex       \n Min.   :1.000  \n 1st Qu.:1.000  \n Median :2.000  \n Mean   :1.584  \n 3rd Qu.:2.000  \n Max.   :2.000  \n```\n:::\n\n```{.r .cell-code}\nsummary(nlsy$income)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      0    6000   11155   15289   20000   75001 \n```\n:::\n:::\n\n\n## Summary statistics\n\nWe can also apply certain functions to a variable(s) to get a single statistic: `mean()`, `median()`, `var()`, `sd()`, `cov()`, `cor()`, `min()`, `max()`, `quantile()`, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(nlsy$age_bir)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22\n```\n:::\n\n```{.r .cell-code}\ncor(nlsy$sleep_wkdy, nlsy$sleep_wknd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7101579\n```\n:::\n\n```{.r .cell-code}\nquantile(nlsy$income, probs = c(0.1, 0.9))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    10%     90% \n 3177.2 33024.0 \n```\n:::\n:::\n\n\n## Summary statistics\n\nBut what if we want a lot of summary statistics -- just not those that come with the `summary()` function?\n\n- For example, it doesn't give us a standard deviation!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(nlsy, \n          med_age_bir = median(age_bir),\n          cor_sleep = cor(sleep_wkdy, sleep_wknd),\n          ten_pctle_inc = quantile(income, probs = 0.1),\n          ninety_pctle_inc = quantile(income, probs = 0.9))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n  med_age_bir cor_sleep ten_pctle_inc ninety_pctle_inc\n        <dbl>     <dbl>         <dbl>            <dbl>\n1          22     0.710         3177.            33024\n```\n:::\n:::\n\n\n## `summarize()` specifics\n\nImportant to note:\n\n- Takes a dataframe as its first argument. That means we can use pipes!\n- Returns a tibble -- helpful if you want to use those values in a figure or table.\n- Can give the summary statistics names.\n- Can ask for any type of function of the variables (including one you make up yourself).\n\n## Combining summarize with other functions\n\nBecause we can pipe, we can also look at statistics of variables that we make using `mutate()`, in a dataset we've subsetted with `filter()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  mutate(age_bir_stand = (age_bir - mean(age_bir)) / sd(age_bir)) |>\n  filter(sex == 1) |>\n  summarize(mean_men = mean(age_bir_stand))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  mean_men\n     <dbl>\n1    0.283\n```\n:::\n:::\n\n\n::: callout-note\nNote that we're standardizing the data *before* filtering.\n:::\n\n# Exercise\n\n## What if we want both groups at once?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  filter(sex == 1) |>\n  summarize(age_bir_men = mean(age_bir))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  age_bir_men\n        <dbl>\n1        25.1\n```\n:::\n\n```{.r .cell-code}\nnlsy |>\n  filter(sex == 2) |>\n  summarize(age_bir_women = mean(age_bir))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  age_bir_women\n          <dbl>\n1          22.2\n```\n:::\n:::\n\n\n## We can \"group\" tibbles using `group_by()`\n\nWe can tell it's \"grouped\" and how many groups there are by printing out the data.\n\nThe data itself won't look different, but we'll be able to perform grouped functions on it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy_by_region <- group_by(nlsy, region)\nnlsy_by_region\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 19\n# Groups:   region [4]\n   glasses eyesight sleep_wkdy sleep_wknd    id nsibs  samp race_eth   sex\n     <dbl>    <dbl>      <dbl>      <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl>\n 1       0        1          5          7     3     3     5        3     2\n 2       1        2          6          7     6     1     1        3     1\n 3       0        2          7          9     8     7     6        3     2\n 4       1        3          6          7    16     3     5        3     2\n 5       0        3         10         10    18     2     1        3     1\n 6       1        2          7          8    20     2     5        3     2\n 7       0        1          8          8    27     1     5        3     2\n 8       1        1          8          8    49     6     5        3     2\n 9       1        2          7          8    57     1     5        3     2\n10       0        1          8          8    67     1     1        3     1\n# ℹ 1,195 more rows\n# ℹ 10 more variables: region <dbl>, income <dbl>, res_1980 <dbl>,\n#   res_2002 <dbl>, age_bir <dbl>, eyesight_cat <fct>, glasses_cat <fct>,\n#   race_eth_cat <fct>, sex_cat <fct>, slp_cat_wkdy <chr>\n```\n:::\n:::\n\n\n## `group_by()`\n\nLike the other functions we've seen, we can use pipes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  mutate(income_stand = (income - mean(income))/sd(income)) |>\n  select(id, region, income_stand, race_eth, sex) |>\n  group_by(race_eth)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,205 × 5\n# Groups:   race_eth [3]\n      id region income_stand race_eth   sex\n   <dbl>  <dbl>        <dbl>    <dbl> <dbl>\n 1     3      1        0.533        3     2\n 2     6      1        1.48         3     1\n 3     8      1       -0.605        3     2\n 4    16      1        2.45         3     2\n 5    18      3       -0.809        3     1\n 6    20      1        2.60         3     2\n 7    27      1        0.353        3     2\n 8    49      1        0.646        3     2\n 9    57      1        0.600        3     2\n10    67      1        1.48         3     1\n# ℹ 1,195 more rows\n```\n:::\n:::\n\n\n## Stratify with `group_by() |> summarize()`\n\nThis function is especially important when calculating summary statistics, which we often want to be stratified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  mutate(income_stand = (income - mean(income))/sd(income)) |>\n  group_by(region) |>\n  summarize(mean_inc = mean(income_stand),\n            sd_inc = sd(income_stand))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  region mean_inc sd_inc\n   <dbl>    <dbl>  <dbl>\n1      1   0.186   1.17 \n2      2   0.106   0.958\n3      3  -0.0891  1.03 \n4      4  -0.145   0.810\n```\n:::\n:::\n\n\n## Multiple layers of groups\n\n:::: {.columns}\n\n::: {.column width=\"62%\"}\nWe can group by multiple variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  group_by(region, sex) |>\n  summarize(mean_inc = mean(income),\n            sd_inc = sd(income),\n            .groups = \"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 4\n  region   sex mean_inc sd_inc\n   <dbl> <dbl>    <dbl>  <dbl>\n1      1     1   20393. 16929.\n2      1     2   15928. 14442.\n3      2     1   19488. 14885.\n4      2     2   14699. 10613.\n5      3     1   15137. 14592.\n6      3     2   13293. 12879.\n7      4     1   12315.  9244.\n8      4     2   14001. 11621.\n```\n:::\n:::\n\n\n:::\n  \n::: {.column width=\"35%\"}\n- This would be much easier to read if we had made region and sex into factor variables with labels!\n- We're telling it we don't want the resulting dataframe to be grouped\n\n:::\n\n:::\n\n## Group within `summarize()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  summarize(mean_inc = mean(income),\n            sd_inc = sd(income),\n            .by = c(region, sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 4\n  region   sex mean_inc sd_inc\n   <dbl> <dbl>    <dbl>  <dbl>\n1      1     2   15928. 14442.\n2      1     1   20393. 16929.\n3      3     1   15137. 14592.\n4      3     2   13293. 12879.\n5      2     1   19488. 14885.\n6      2     2   14699. 10613.\n7      4     1   12315.  9244.\n8      4     2   14001. 11621.\n```\n:::\n:::\n\n\nThis is a relatively new feature of this function and is very handy!\n\n## Counting groups\n\n\n:::: {.columns}\n\n::: {.column width=\"49%\"}\nSometimes we just want to know how many observations are in a group. We can do that (at least) three ways!\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  group_by(sex) |>\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n    sex     n\n  <dbl> <int>\n1     1   501\n2     2   704\n```\n:::\n:::\n\n\n:::\n  \n::: {.column width=\"48%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |>\n  group_by(sex) |>\n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n    sex     n\n  <dbl> <int>\n1     1   501\n2     2   704\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnlsy |> \n  count(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n    sex     n\n  <dbl> <int>\n1     1   501\n2     2   704\n```\n:::\n:::\n\n\n:::\n  \n::::\n\n# Exercise",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}